{"ast":null,"code":"(function () {\n  var $P = Date.Parsing;\n\n  var _ = $P.Operators = {\n    //\n    // Tokenizers\n    //\n    rtoken: function (r) {\n      // regex token\n      return function (s) {\n        var mx = s.match(r);\n\n        if (mx) {\n          return [mx[0], s.substring(mx[0].length)];\n        } else {\n          throw new $P.Exception(s);\n        }\n      };\n    },\n    token: function () {\n      // whitespace-eating token\n      return function (s) {\n        return _.rtoken(new RegExp(\"^\\\\s*\" + s + \"\\\\s*\"))(s);\n      };\n    },\n    stoken: function (s) {\n      // string token\n      return _.rtoken(new RegExp(\"^\" + s));\n    },\n    // Atomic Operators\n    until: function (p) {\n      return function (s) {\n        var qx = [],\n            rx = null;\n\n        while (s.length) {\n          try {\n            rx = p.call(this, s);\n          } catch (e) {\n            qx.push(rx[0]);\n            s = rx[1];\n            continue;\n          }\n\n          break;\n        }\n\n        return [qx, s];\n      };\n    },\n    many: function (p) {\n      return function (s) {\n        var rx = [],\n            r = null;\n\n        while (s.length) {\n          try {\n            r = p.call(this, s);\n          } catch (e) {\n            return [rx, s];\n          }\n\n          rx.push(r[0]);\n          s = r[1];\n        }\n\n        return [rx, s];\n      };\n    },\n    // generator operators -- see below\n    optional: function (p) {\n      return function (s) {\n        var r = null;\n\n        try {\n          r = p.call(this, s);\n        } catch (e) {\n          return [null, s];\n        }\n\n        return [r[0], r[1]];\n      };\n    },\n    not: function (p) {\n      return function (s) {\n        try {\n          p.call(this, s);\n        } catch (e) {\n          return [null, s];\n        }\n\n        throw new $P.Exception(s);\n      };\n    },\n    ignore: function (p) {\n      return p ? function (s) {\n        var r = null;\n        r = p.call(this, s);\n        return [null, r[1]];\n      } : null;\n    },\n    product: function () {\n      var px = arguments[0],\n          qx = Array.prototype.slice.call(arguments, 1),\n          rx = [];\n\n      for (var i = 0; i < px.length; i++) {\n        rx.push(_.each(px[i], qx));\n      }\n\n      return rx;\n    },\n    cache: function (rule) {\n      var cache = {},\n          cache_length = 0,\n          cache_keys = [],\n          CACHE_MAX = Date.Config.CACHE_MAX || 100000,\n          r = null;\n\n      var cacheCheck = function () {\n        if (cache_length === CACHE_MAX) {\n          // kill several keys, don't want to have to do this all the time...\n          for (var i = 0; i < 10; i++) {\n            var key = cache_keys.shift();\n\n            if (key) {\n              delete cache[key];\n              cache_length--;\n            }\n          }\n        }\n      };\n\n      return function (s) {\n        cacheCheck();\n\n        try {\n          r = cache[s] = cache[s] || rule.call(this, s);\n        } catch (e) {\n          r = cache[s] = e;\n        }\n\n        cache_length++;\n        cache_keys.push(s);\n\n        if (r instanceof $P.Exception) {\n          throw r;\n        } else {\n          return r;\n        }\n      };\n    },\n    // vector operators -- see below\n    any: function () {\n      var px = arguments;\n      return function (s) {\n        var r = null;\n\n        for (var i = 0; i < px.length; i++) {\n          if (px[i] == null) {\n            continue;\n          }\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            r = null;\n          }\n\n          if (r) {\n            return r;\n          }\n        }\n\n        throw new $P.Exception(s);\n      };\n    },\n    each: function () {\n      var px = arguments;\n      return function (s) {\n        var rx = [],\n            r = null;\n\n        for (var i = 0; i < px.length; i++) {\n          if (px[i] == null) {\n            continue;\n          }\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            throw new $P.Exception(s);\n          }\n\n          rx.push(r[0]);\n          s = r[1];\n        }\n\n        return [rx, s];\n      };\n    },\n    all: function () {\n      var px = arguments,\n          _ = _;\n      return _.each(_.optional(px));\n    },\n    // delimited operators\n    sequence: function (px, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n\n      if (px.length === 1) {\n        return px[0];\n      }\n\n      return function (s) {\n        var r = null,\n            q = null;\n        var rx = [];\n\n        for (var i = 0; i < px.length; i++) {\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            break;\n          }\n\n          rx.push(r[0]);\n\n          try {\n            q = d.call(this, r[1]);\n          } catch (ex) {\n            q = null;\n            break;\n          }\n\n          s = q[1];\n        }\n\n        if (!r) {\n          throw new $P.Exception(s);\n        }\n\n        if (q) {\n          throw new $P.Exception(q[1]);\n        }\n\n        if (c) {\n          try {\n            r = c.call(this, r[1]);\n          } catch (ey) {\n            throw new $P.Exception(r[1]);\n          }\n        }\n\n        return [rx, r ? r[1] : s];\n      };\n    },\n    //\n    // Composite Operators\n    //\n    between: function (d1, p, d2) {\n      d2 = d2 || d1;\n\n      var _fn = _.each(_.ignore(d1), p, _.ignore(d2));\n\n      return function (s) {\n        var rx = _fn.call(this, s);\n\n        return [[rx[0][0], r[0][2]], rx[1]];\n      };\n    },\n    list: function (p, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n      return p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c));\n    },\n    set: function (px, d, c) {\n      d = d || _.rtoken(/^\\s*/);\n      c = c || null;\n      return function (s) {\n        // r is the current match, best the current 'best' match\n        // which means it parsed the most amount of input\n        var r = null,\n            p = null,\n            q = null,\n            rx = null,\n            best = [[], s],\n            last = false; // go through the rules in the given set\n\n        for (var i = 0; i < px.length; i++) {\n          // last is a flag indicating whether this must be the last element\n          // if there is only 1 element, then it MUST be the last one\n          q = null;\n          p = null;\n          r = null;\n          last = px.length === 1; // first, we try simply to match the current pattern\n          // if not, try the next pattern\n\n          try {\n            r = px[i].call(this, s);\n          } catch (e) {\n            continue;\n          } // since we are matching against a set of elements, the first\n          // thing to do is to add r[0] to matched elements\n\n\n          rx = [[r[0]], r[1]]; // if we matched and there is still input to parse and \n          // we don't already know this is the last element,\n          // we're going to next check for the delimiter ...\n          // if there's none, or if there's no input left to parse\n          // than this must be the last element after all ...\n\n          if (r[1].length > 0 && !last) {\n            try {\n              q = d.call(this, r[1]);\n            } catch (ex) {\n              last = true;\n            }\n          } else {\n            last = true;\n          } // if we parsed the delimiter and now there's no more input,\n          // that means we shouldn't have parsed the delimiter at all\n          // so don't update r and mark this as the last element ...\n\n\n          if (!last && q[1].length === 0) {\n            last = true;\n          } // so, if this isn't the last element, we're going to see if\n          // we can get any more matches from the remaining (unmatched)\n          // elements ...\n\n\n          if (!last) {\n            // build a list of the remaining rules we can match against,\n            // i.e., all but the one we just matched against\n            var qx = [];\n\n            for (var j = 0; j < px.length; j++) {\n              if (i !== j) {\n                qx.push(px[j]);\n              }\n            } // now invoke recursively set with the remaining input\n            // note that we don't include the closing delimiter ...\n            // we'll check for that ourselves at the end\n\n\n            p = _.set(qx, d).call(this, q[1]); // if we got a non-empty set as a result ...\n            // (otw rx already contains everything we want to match)\n\n            if (p[0].length > 0) {\n              // update current result, which is stored in rx ...\n              // basically, pick up the remaining text from p[1]\n              // and concat the result from p[0] so that we don't\n              // get endless nesting ...\n              rx[0] = rx[0].concat(p[0]);\n              rx[1] = p[1];\n            }\n          } // at this point, rx either contains the last matched element\n          // or the entire matched set that starts with this element.\n          // now we just check to see if this variation is better than\n          // our best so far, in terms of how much of the input is parsed\n\n\n          if (rx[1].length < best[1].length) {\n            best = rx;\n          } // if we've parsed all the input, then we're finished\n\n\n          if (best[1].length === 0) {\n            break;\n          }\n        } // so now we've either gone through all the patterns trying them\n        // as the initial match; or we found one that parsed the entire\n        // input string ...\n        // if best has no matches, just return empty set ...\n\n\n        if (best[0].length === 0) {\n          return best;\n        } // if a closing delimiter is provided, then we have to check it also\n\n\n        if (c) {\n          // we try this even if there is no remaining input because the pattern\n          // may well be optional or match empty input ...\n          try {\n            q = c.call(this, best[1]);\n          } catch (ey) {\n            throw new $P.Exception(best[1]);\n          } // it parsed ... be sure to update the best match remaining input\n\n\n          best[1] = q[1];\n        } // if we're here, either there was no closing delimiter or we parsed it\n        // so now we have the best match; just return it!\n\n\n        return best;\n      };\n    },\n    forward: function (gr, fname) {\n      return function (s) {\n        return gr[fname].call(this, s);\n      };\n    },\n    //\n    // Translation Operators\n    //\n    replace: function (rule, repl) {\n      return function (s) {\n        var r = rule.call(this, s);\n        return [repl, r[1]];\n      };\n    },\n    process: function (rule, fn) {\n      return function (s) {\n        var r = rule.call(this, s);\n        return [fn.call(this, r[0]), r[1]];\n      };\n    },\n    min: function (min, rule) {\n      return function (s) {\n        var rx = rule.call(this, s);\n\n        if (rx[0].length < min) {\n          throw new $P.Exception(s);\n        }\n\n        return rx;\n      };\n    }\n  }; // Generator Operators And Vector Operators\n  // Generators are operators that have a signature of F(R) => R,\n  // taking a given rule and returning another rule, such as \n  // ignore, which parses a given rule and throws away the result.\n  // Vector operators are those that have a signature of F(R1,R2,...) => R,\n  // take a list of rules and returning a new rule, such as each.\n  // Generator operators are converted (via the following _generator\n  // function) into functions that can also take a list or array of rules\n  // and return an array of new rules as though the function had been\n  // called on each rule in turn (which is what actually happens).\n  // This allows generators to be used with vector operators more easily.\n  // Example:\n  // each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))\n  // This also turns generators into vector operators, which allows\n  // constructs like:\n  // not(cache(foo, bar))\n\n\n  var _generator = function (op) {\n    function gen() {\n      var args = null,\n          rx = [],\n          px,\n          i;\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      } else if (arguments[0] instanceof Array) {\n        args = arguments[0];\n      }\n\n      if (args) {\n        px = args.shift();\n\n        if (px.length > 0) {\n          args.unshift(px[i]);\n          rx.push(op.apply(null, args));\n          args.shift();\n          return rx;\n        }\n      } else {\n        return op.apply(null, arguments);\n      }\n    }\n\n    return gen;\n  };\n\n  var gx = \"optional not ignore cache\".split(/\\s/);\n\n  for (var i = 0; i < gx.length; i++) {\n    _[gx[i]] = _generator(_[gx[i]]);\n  }\n\n  var _vector = function (op) {\n    return function () {\n      if (arguments[0] instanceof Array) {\n        return op.apply(null, arguments[0]);\n      } else {\n        return op.apply(null, arguments);\n      }\n    };\n  };\n\n  var vx = \"each any all\".split(/\\s/);\n\n  for (var j = 0; j < vx.length; j++) {\n    _[vx[j]] = _vector(_[vx[j]]);\n  }\n})();","map":{"version":3,"sources":["/Users/pedro/Dev/nodejs/crawler_brighton/brighton-rocks/node_modules/datejs/src/core/parsing_operators.js"],"names":["$P","Date","Parsing","_","Operators","rtoken","r","s","mx","match","substring","length","Exception","token","RegExp","stoken","until","p","qx","rx","call","e","push","many","optional","not","ignore","product","px","arguments","Array","prototype","slice","i","each","cache","rule","cache_length","cache_keys","CACHE_MAX","Config","cacheCheck","key","shift","any","all","sequence","d","c","q","ex","ey","between","d1","d2","_fn","list","set","best","last","j","concat","forward","gr","fname","replace","repl","process","fn","min","_generator","op","gen","args","unshift","apply","gx","split","_vector","vx"],"mappings":"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","sourcesContent":["(function () {\n\tvar $P = Date.Parsing;\n\tvar _ = $P.Operators = {\n\t\t//\n\t\t// Tokenizers\n\t\t//\n\t\trtoken: function (r) { // regex token\n\t\t\treturn function (s) {\n\t\t\t\tvar mx = s.match(r);\n\t\t\t\tif (mx) {\n\t\t\t\t\treturn ([ mx[0], s.substring(mx[0].length) ]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new $P.Exception(s);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\ttoken: function () { // whitespace-eating token\n\t\t\treturn function (s) {\n\t\t\t\treturn _.rtoken(new RegExp(\"^\\\\s*\" + s + \"\\\\s*\"))(s);\n\t\t\t};\n\t\t},\n\t\tstoken: function (s) { // string token\n\t\t\treturn _.rtoken(new RegExp(\"^\" + s));\n\t\t},\n\n\t\t// Atomic Operators\n\n\t\tuntil: function (p) {\n\t\t\treturn function (s) {\n\t\t\t\tvar qx = [], rx = null;\n\t\t\t\twhile (s.length) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trx = p.call(this, s);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tqx.push(rx[0]);\n\t\t\t\t\t\ts = rx[1];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn [ qx, s ];\n\t\t\t};\n\t\t},\n\t\tmany: function (p) {\n\t\t\treturn function (s) {\n\t\t\t\tvar rx = [], r = null;\n\t\t\t\twhile (s.length) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = p.call(this, s);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn [ rx, s ];\n\t\t\t\t\t}\n\t\t\t\t\trx.push(r[0]);\n\t\t\t\t\ts = r[1];\n\t\t\t\t}\n\t\t\t\treturn [ rx, s ];\n\t\t\t};\n\t\t},\n\n\t\t// generator operators -- see below\n\t\toptional: function (p) {\n\t\t\treturn function (s) {\n\t\t\t\tvar r = null;\n\t\t\t\ttry {\n\t\t\t\t\tr = p.call(this, s);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn [ null, s ];\n\t\t\t\t}\n\t\t\t\treturn [ r[0], r[1] ];\n\t\t\t};\n\t\t},\n\t\tnot: function (p) {\n\t\t\treturn function (s) {\n\t\t\t\ttry {\n\t\t\t\t\tp.call(this, s);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn [null, s];\n\t\t\t\t}\n\t\t\t\tthrow new $P.Exception(s);\n\t\t\t};\n\t\t},\n\t\tignore: function (p) {\n\t\t\treturn p ?\n\t\t\tfunction (s) {\n\t\t\t\tvar r = null;\n\t\t\t\tr = p.call(this, s);\n\t\t\t\treturn [null, r[1]];\n\t\t\t} : null;\n\t\t},\n\t\tproduct: function () {\n\t\t\tvar px = arguments[0],\n\t\t\tqx = Array.prototype.slice.call(arguments, 1), rx = [];\n\t\t\tfor (var i = 0 ; i < px.length ; i++) {\n\t\t\t\trx.push(_.each(px[i], qx));\n\t\t\t}\n\t\t\treturn rx;\n\t\t},\n\t\tcache: function (rule) {\n\t\t\tvar cache = {}, cache_length = 0, cache_keys = [], CACHE_MAX = Date.Config.CACHE_MAX || 100000, r = null;\n\t\t\tvar cacheCheck = function () {\n\t\t\t\tif (cache_length === CACHE_MAX) {\n\t\t\t\t\t// kill several keys, don't want to have to do this all the time...\n\t\t\t\t\tfor (var i=0; i < 10; i++) {\n\t\t\t\t\t\tvar key = cache_keys.shift();\n\t\t\t\t\t\tif (key) {\n\t\t\t\t\t\t\tdelete cache[key];\n\t\t\t\t\t\t\tcache_length--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn function (s) {\n\t\t\t\tcacheCheck();\n\t\t\t\ttry {\n\t\t\t\t\tr = cache[s] = (cache[s] || rule.call(this, s));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tr = cache[s] = e;\n\t\t\t\t}\n\t\t\t\tcache_length++;\n\t\t\t\tcache_keys.push(s);\n\t\t\t\tif (r instanceof $P.Exception) {\n\t\t\t\t\tthrow r;\n\t\t\t\t} else {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t// vector operators -- see below\n\t\tany: function () {\n\t\t\tvar px = arguments;\n\t\t\treturn function (s) {\n\t\t\t\tvar r = null;\n\t\t\t\tfor (var i = 0; i < px.length; i++) {\n\t\t\t\t\tif (px[i] == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = (px[i].call(this, s));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tr = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new $P.Exception(s);\n\t\t\t};\n\t\t},\n\t\teach: function () {\n\t\t\tvar px = arguments;\n\t\t\treturn function (s) {\n\t\t\t\tvar rx = [], r = null;\n\t\t\t\tfor (var i = 0; i < px.length ; i++) {\n\t\t\t\t\tif (px[i] == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = (px[i].call(this, s));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new $P.Exception(s);\n\t\t\t\t\t}\n\t\t\t\t\trx.push(r[0]);\n\t\t\t\t\ts = r[1];\n\t\t\t\t}\n\t\t\t\treturn [ rx, s];\n\t\t\t};\n\t\t},\n\t\tall: function () {\n\t\t\tvar px = arguments, _ = _;\n\t\t\treturn _.each(_.optional(px));\n\t\t},\n\n\t\t// delimited operators\n\t\tsequence: function (px, d, c) {\n\t\t\td = d || _.rtoken(/^\\s*/);\n\t\t\tc = c || null;\n\t\t\t\n\t\t\tif (px.length === 1) {\n\t\t\t\treturn px[0];\n\t\t\t}\n\t\t\treturn function (s) {\n\t\t\t\tvar r = null, q = null;\n\t\t\t\tvar rx = [];\n\t\t\t\tfor (var i = 0; i < px.length ; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = px[i].call(this, s);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trx.push(r[0]);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tq = d.call(this, r[1]);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tq = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts = q[1];\n\t\t\t\t}\n\t\t\t\tif (!r) {\n\t\t\t\t\tthrow new $P.Exception(s);\n\t\t\t\t}\n\t\t\t\tif (q) {\n\t\t\t\t\tthrow new $P.Exception(q[1]);\n\t\t\t\t}\n\t\t\t\tif (c) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = c.call(this, r[1]);\n\t\t\t\t\t} catch (ey) {\n\t\t\t\t\t\tthrow new $P.Exception(r[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [ rx, (r?r[1]:s) ];\n\t\t\t};\n\t\t},\n\n\t\t//\n\t\t// Composite Operators\n\t\t//\n\n\t\tbetween: function (d1, p, d2) {\n\t\t\td2 = d2 || d1;\n\t\t\tvar _fn = _.each(_.ignore(d1), p, _.ignore(d2));\n\t\t\treturn function (s) {\n\t\t\t\tvar rx = _fn.call(this, s);\n\t\t\t\treturn [[rx[0][0], r[0][2]], rx[1]];\n\t\t\t};\n\t\t},\n\t\tlist: function (p, d, c) {\n\t\t\td = d || _.rtoken(/^\\s*/);\n\t\t\tc = c || null;\n\t\t\treturn (p instanceof Array ?\n\t\t\t\t_.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) :\n\t\t\t\t_.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));\n\t\t},\n\t\tset: function (px, d, c) {\n\t\t\td = d || _.rtoken(/^\\s*/);\n\t\t\tc = c || null;\n\t\t\treturn function (s) {\n\t\t\t\t// r is the current match, best the current 'best' match\n\t\t\t\t// which means it parsed the most amount of input\n\t\t\t\tvar r = null, p = null, q = null, rx = null, best = [[], s], last = false;\n\t\t\t\t// go through the rules in the given set\n\t\t\t\tfor (var i = 0; i < px.length ; i++) {\n\n\t\t\t\t\t// last is a flag indicating whether this must be the last element\n\t\t\t\t\t// if there is only 1 element, then it MUST be the last one\n\t\t\t\t\tq = null;\n\t\t\t\t\tp = null;\n\t\t\t\t\tr = null;\n\t\t\t\t\tlast = (px.length === 1);\n\t\t\t\t\t// first, we try simply to match the current pattern\n\t\t\t\t\t// if not, try the next pattern\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = px[i].call(this, s);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// since we are matching against a set of elements, the first\n\t\t\t\t\t// thing to do is to add r[0] to matched elements\n\t\t\t\t\trx = [[r[0]], r[1]];\n\t\t\t\t\t// if we matched and there is still input to parse and \n\t\t\t\t\t// we don't already know this is the last element,\n\t\t\t\t\t// we're going to next check for the delimiter ...\n\t\t\t\t\t// if there's none, or if there's no input left to parse\n\t\t\t\t\t// than this must be the last element after all ...\n\t\t\t\t\tif (r[1].length > 0 && ! last) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tq = d.call(this, r[1]);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tlast = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlast = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we parsed the delimiter and now there's no more input,\n\t\t\t\t\t// that means we shouldn't have parsed the delimiter at all\n\t\t\t\t\t// so don't update r and mark this as the last element ...\n\t\t\t\t\tif (!last && q[1].length === 0) {\n\t\t\t\t\t\tlast = true;\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// so, if this isn't the last element, we're going to see if\n\t\t\t\t\t// we can get any more matches from the remaining (unmatched)\n\t\t\t\t\t// elements ...\n\t\t\t\t\tif (!last) {\n\t\t\t\t\t\t// build a list of the remaining rules we can match against,\n\t\t\t\t\t\t// i.e., all but the one we just matched against\n\t\t\t\t\t\tvar qx = [];\n\t\t\t\t\t\tfor (var j = 0; j < px.length ; j++) {\n\t\t\t\t\t\t\tif (i !== j) {\n\t\t\t\t\t\t\t\tqx.push(px[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// now invoke recursively set with the remaining input\n\t\t\t\t\t\t// note that we don't include the closing delimiter ...\n\t\t\t\t\t\t// we'll check for that ourselves at the end\n\t\t\t\t\t\tp = _.set(qx, d).call(this, q[1]);\n\n\t\t\t\t\t\t// if we got a non-empty set as a result ...\n\t\t\t\t\t\t// (otw rx already contains everything we want to match)\n\t\t\t\t\t\tif (p[0].length > 0) {\n\t\t\t\t\t\t\t// update current result, which is stored in rx ...\n\t\t\t\t\t\t\t// basically, pick up the remaining text from p[1]\n\t\t\t\t\t\t\t// and concat the result from p[0] so that we don't\n\t\t\t\t\t\t\t// get endless nesting ...\n\t\t\t\t\t\t\trx[0] = rx[0].concat(p[0]);\n\t\t\t\t\t\t\trx[1] = p[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// at this point, rx either contains the last matched element\n\t\t\t\t\t// or the entire matched set that starts with this element.\n\n\t\t\t\t\t// now we just check to see if this variation is better than\n\t\t\t\t\t// our best so far, in terms of how much of the input is parsed\n\t\t\t\t\tif (rx[1].length < best[1].length) {\n\t\t\t\t\t\tbest = rx;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we've parsed all the input, then we're finished\n\t\t\t\t\tif (best[1].length === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// so now we've either gone through all the patterns trying them\n\t\t\t\t// as the initial match; or we found one that parsed the entire\n\t\t\t\t// input string ...\n\n\t\t\t\t// if best has no matches, just return empty set ...\n\t\t\t\tif (best[0].length === 0) {\n\t\t\t\t\treturn best;\n\t\t\t\t}\n\n\t\t\t\t// if a closing delimiter is provided, then we have to check it also\n\t\t\t\tif (c) {\n\t\t\t\t\t// we try this even if there is no remaining input because the pattern\n\t\t\t\t\t// may well be optional or match empty input ...\n\t\t\t\t\ttry {\n\t\t\t\t\t\tq = c.call(this, best[1]);\n\t\t\t\t\t} catch (ey) {\n\t\t\t\t\t\tthrow new $P.Exception(best[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// it parsed ... be sure to update the best match remaining input\n\t\t\t\t\tbest[1] = q[1];\n\t\t\t\t}\n\t\t\t\t// if we're here, either there was no closing delimiter or we parsed it\n\t\t\t\t// so now we have the best match; just return it!\n\t\t\t\treturn best;\n\t\t\t};\n\t\t},\n\t\tforward: function (gr, fname) {\n\t\t\treturn function (s) {\n\t\t\t\treturn gr[fname].call(this, s);\n\t\t\t};\n\t\t},\n\n\t\t//\n\t\t// Translation Operators\n\t\t//\n\t\treplace: function (rule, repl) {\n\t\t\treturn function (s) {\n\t\t\t\tvar r = rule.call(this, s);\n\t\t\t\treturn [repl, r[1]];\n\t\t\t};\n\t\t},\n\t\tprocess: function (rule, fn) {\n\t\t\treturn function (s) {\n\t\t\t\tvar r = rule.call(this, s);\n\t\t\t\treturn [fn.call(this, r[0]), r[1]];\n\t\t\t};\n\t\t},\n\t\tmin: function (min, rule) {\n\t\t\treturn function (s) {\n\t\t\t\tvar rx = rule.call(this, s);\n\t\t\t\tif (rx[0].length < min) {\n\t\t\t\t\tthrow new $P.Exception(s);\n\t\t\t\t}\n\t\t\t\treturn rx;\n\t\t\t};\n\t\t}\n\t};\n\t\n\n\t// Generator Operators And Vector Operators\n\n\t// Generators are operators that have a signature of F(R) => R,\n\t// taking a given rule and returning another rule, such as \n\t// ignore, which parses a given rule and throws away the result.\n\n\t// Vector operators are those that have a signature of F(R1,R2,...) => R,\n\t// take a list of rules and returning a new rule, such as each.\n\n\t// Generator operators are converted (via the following _generator\n\t// function) into functions that can also take a list or array of rules\n\t// and return an array of new rules as though the function had been\n\t// called on each rule in turn (which is what actually happens).\n\n\t// This allows generators to be used with vector operators more easily.\n\t// Example:\n\t// each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))\n\n\t// This also turns generators into vector operators, which allows\n\t// constructs like:\n\t// not(cache(foo, bar))\n\t\n\tvar _generator = function (op) {\n\t\tfunction gen() {\n\t\t\tvar args = null, rx = [], px, i;\n\t\t\tif (arguments.length > 1) {\n\t\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\targs = arguments[0];\n\t\t\t}\n\t\t\tif (args) {\n\t\t\t\tpx = args.shift();\n\t\t\t\tif (px.length > 0) {\n\t\t\t\t\targs.unshift(px[i]);\n\t\t\t\t\trx.push(op.apply(null, args));\n\t\t\t\t\targs.shift();\n\t\t\t\t\treturn rx;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn op.apply(null, arguments);\n\t\t\t}\n\t\t}\n\n\t\treturn gen;\n\t};\n\t\n\tvar gx = \"optional not ignore cache\".split(/\\s/);\n\t\n\tfor (var i = 0 ; i < gx.length ; i++) {\n\t\t_[gx[i]] = _generator(_[gx[i]]);\n\t}\n\n\tvar _vector = function (op) {\n\t\treturn function () {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\treturn op.apply(null, arguments[0]);\n\t\t\t} else {\n\t\t\t\treturn op.apply(null, arguments);\n\t\t\t}\n\t\t};\n\t};\n\t\n\tvar vx = \"each any all\".split(/\\s/);\n\t\n\tfor (var j = 0 ; j < vx.length ; j++) {\n\t\t_[vx[j]] = _vector(_[vx[j]]);\n\t}\n\t\n}());"]},"metadata":{},"sourceType":"script"}